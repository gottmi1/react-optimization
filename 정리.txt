컴포넌트가 재실행되면(props나 state 컨텍스트등이 바뀌면)
그 컴포넌트의 모든 자식 컴포넌트 역시 재실행,재평가 된다.

상태가 바뀌지않는 자식 컴포넌트들도 모두 재실행 해버림.
이 때 예외로 두고싶은 컴포넌트는 React.memo를 사용하여 업데이트되지 않게 한다.

React.memo사용법 : export 할 때 컴포넌트를 묶는다
export default React.memo(DemoOutput); 이렇게.
이 컴포넌트이 재실행을 막는 것이므로 자식 컴포넌트도 재실행되지 않는다.

이렇게 편리한데 모든 컴포넌트에 사용하지않는 이유? cost가 발생해서.
App.js에 변경이 발생할 때 마다 해당 컴포넌트로 이동하여 기존 props값과 새로운 값을 비교한다.
이럴려면 기존의 props를 저장할 공간이 필요하고 비교하는 작업도 필요하기 때문에 모든 곳에 쓸수는 없음
자식 컴포넌트가 많아서 트리의 크기가 매우 클때 유용하다.

그러나 부모 컴포넌트를 재실행 할 때마다 변경이 있거나 하는 경우 React.memo는 의미가 없음.


- useCallback

useCallback은 선택한 함수를 리액트 내부 저장공간에 저장해서 함수 객체가 실행될 때마다 새로 생성하는 것이 아니라, 저장된 것을 재사용할 수 있게 한다.
최적화하기에 아주 좋은 훅임. 
디펜던시에 빈 배열을 주면 절대 변하지않는 함수를 만들 수 있다.
※ useCallback밖의 스코프에서 선언된 상태를 안에서 사용하면, 초기 설정된 값에서 바뀌지 않음.

- 요약

리액트의 함수형 컴포넌트는 요소를 리턴하는 함수이다.
props나 state등 요소들의 상태가 변경되었을 때 재평가를 한다.
이는 함수를 재실행한다는 뜻임.
DOM에서 이전 스냅샷과 최신 스냅샷을 비교해 바뀐 곳만 리렌더링하게 됨.
이 때 요소에 React.memo를 사용하면 그 요소에 props가 실제로 변경되었을 때, 새로운 정보가 들어왔을 때만 리렌더링 하게 함.

그런데 이때 props의 onClick 등에 컴포넌트 내에서 생성된 새로운 객체를 리턴하는 함수를 넣었을 경우 React.memo는 의미가 없다. 
이유 : 객체는 참조값인데, React.memo가 내부적으로 사용하는 등호를 통한 비교는 원시값에 대해서는 통하지 않기 때문.

이럴 때 useCallback을 사용하면 된다. 디펜던시에 의존하여 재실행할지 말지를 정할 수 있기 때문이다.

- state detail

상태와 컴포넌트의 상호작용은 리액트에서 가장 중요하다고 할 수 있는 요소임.
상태를 통하여 컴포넌트를 리렌더링하고, 화면에 표시되는 것들을 바꾸기 때문이다.

큰 의미는 없지만 컴포넌트가 재평가될 때 useState등의 훅까지 초기화하지 않는 이유는 애초에 최초의 초기화 이후에는 갱신만 하도록 설계된 라이브러리이기 때문. 컴포넌트가 삭제되었다가 다시 연결되는 경우엔 상태가 초기화될 수도 있음.

- 상태 업데이트 스케쥴링

새로운 상태를 set했을 때, 인간이 보기에는 즉각적으로 상태가 업데이트된 것처럼 보이지만, 사실  react는 바로 변경하지않고 상태 업데이트 예약을 한 후 업데이트한다.

이유 : 상태 변경에도 우선순위가 있기 때문인데, 예를들어 인풋에 텍스트를 입력해서 key값이 변경되는 것이 상태 업데이트보다 우선순위가 높기 때문에 동시에 여러가지 변경이 일어나면 업데이트의 지연이 일어날 수도 있다는 것 같다. 컴포넌트가 리렌더되는 시점과 상태 변경이 예약되는 시점의 차이를 이해하는 게 중요하다.

거의 일어나지 않는 일이지만, 이론상 이 스케쥴링이 지연될 수 있으므로, 전 스냅샷에 의존하는 함수 형태를 이용해서 갱신하는 것이 권장된다.
한 함수에 여러가지 상태 업데이트를 놓더라고, 프로미스나 콜백이 없다면 그 함수 전체를 하나의 상태 갱신 작업으로 처리한다.

한마디로 스케쥴링은 상태가 set됨 -> 이때 바로 상태를 업데이트 하지 않음 -> 해당 컴포넌트가 재평가 됨 -> 최신상태가 업데이트됨이라고 보면 될듯 하다.

- useMemo 

useCallback이 함수를 저장해놓고 사용하기 위한 것이라면 useMemo는 그외 다른 것들을 저장해놓고 사용기 위한 것이다.

예를들어 sort해야하는 배열이 있을 때, useMemo가 없다면 매번 sort메서드를 재실행하고 새로운 배열을 만들어야 하는데, useMemo로 저장해놓으면 재생성 할 필요가 없어지는 것.

그러나 useMemo를 사용한다는 건 일정한 저장공간을 사용한다는 것으로, 성능저하를 야기할 수 있기 때문에 자주 사용되지는 않는다.